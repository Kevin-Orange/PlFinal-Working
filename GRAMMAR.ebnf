(* EBNF grammar for the language implemented in lang/src/* *)

(* Start symbol *)
<program> ::= { <func_decl> } ;

(* Functions *)
<func_decl> ::= "func" <id> "(" [ <params> ] ")" [ "->" <type> ] <block> ;
<params> ::= <param> { "," <param> } ;
<param> ::= <id> ":" <type> ;

(* Types *)
<type> ::= "i32" | "f32" | "char" | "bool" ;

(* Statements and blocks *)
<block> ::= "[" { <stmt> } "]" ;
<stmt> ::= <let_stmt>
         |  <if_stmt>
         |  <while_stmt>
         |  <return_stmt>
         |  <print_stmt>
         |  <expr_stmt> ;

<let_stmt> ::= "let" <id> [ ":" <type> ] [ "=" <expr> ] ";" ;
<if_stmt> ::= "if" <expr> <block> [ "else" <block> ] ;
<while_stmt> ::= "while" <expr> <block> ;
<return_stmt> ::= "return" <expr> ";" ;
<print_stmt> ::= "print" <expr> ";" ;
<expr_stmt> ::= <expr> ";" ;

(* Expressions (precedence handled by Pratt parser) *)
<expr> ::= <assign> ;
<assign> ::= <or_expr> | <id> "=" <assign> ;
<or_expr> ::= <and_expr> { "||" <and_expr> } ;
<and_expr> ::= <eq_expr> { "&&" <eq_expr> } ;
<eq_expr> ::= <rel_expr> { ( "==" | "!=" ) <rel_expr> } ;
<rel_expr> ::= <add_expr> { ( "<" | ">" | "<=" | ">=" ) <add_expr> } ;
<add_expr> ::= <mul_expr> { ( "+" | "-" ) <mul_expr> } ;
<mul_expr> ::= <unary> { ( "*" | "/" ) <unary> } ;
<unary> ::= <primary> | ( "!" | "-" ) <unary> ;
<primary> ::= <id> | <literal> | <call> | "(" <expr> ")" ;
<call> ::= <id> "(" [ <args> ] ")" ;
<args> ::= <expr> { "," <expr> } ;

(* Lexical *)
<id> ::= ( letter | "_" ) { letter | digit | "_" | "-" } ;
<literal> ::= <int> | <float> | <char> | <bool> | <string> ;
<int> ::= digit { digit } ;
<float> ::= digit { digit } "." digit { digit } ;
<char> ::= "'" character "'" ;
<bool> ::= "true" | "false" ;
<string> ::= '"' { character } '"' ;
letter ::= "a".."z" | "A".."Z" ;
digit ::= "0".."9" ;

(* Comments / whitespace *)
<comment> ::= "//" { character } ;
<ws> ::= { ' ' | '\t' | '\n' | '\r' } ;
(* Note: <ws> and <comment> are skipped by the lexer. *)

(* Notes *)
(* - 'print' is a reserved keyword and forms a statement, not a normal call. *)
(* - 'return' requires an expression in the current implementation. *)
(* - Identifiers currently allow '-' inside them (lexer behavior). *)
(* - Assignment is right-associative: a = b = 1  -> a = (b = 1). *)
